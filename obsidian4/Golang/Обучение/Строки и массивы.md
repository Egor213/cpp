+ При каждой итерации создаётся новая Уникальная копия
+ В го массивы аллоцируются в стейке если его размер меньше или равен 10 мб
+ При обращении к чужой области памяти будет паника, даже если капасити допускает. Если указать отриц размер слайс или размер больше капы - паника
+ При создании слайс пустой это nil, и вообще слайс - структура указатель на массив, длина и капа
+ При передаче в функцию (например), у слайса копируется только структура, а массив копируется полностью
+ При использовании range, указанное выражение вычисляется только 1 раз, перед началом цикла. Поэтому цикл по слайса, в которые добавляются элементы не бесконечный с range и бесконечный с len(data)
+ В range тоже происходит копирование
![[Pasted image 20250629111537.png]]
+ Срез можно брать от nil слайса
+ Нельзя брать срез больше капасити, но можно брать больше, чем длина
+ При измении длины/емкости одного среза, изменения никак не отображаются на другом срезе!
+ Нежданчик
![[Pasted image 20250629114147.png]]
+ Для удаления элемента с конца среза можно просто порезать его
+ Если у нас есть большой срез, то при использовании clip функции (под капотом data[:10:10]) капасити за границами никто не подчистить. Для нормальной работы надо выделять новый участок памяти и копировать туда данные.
+ Срезы аллоцируются на стеке, если их размер меньше 64 кб. Любая реаллокация перекинет его в кучу.

#### Разница пустых и нулевых срезов
+ Срез считается пустым, если его длина 0
+ Срез считается нулевым, если его значение nil 
+ Пустой срез указывает на адрес пустой структуры, то есть в никуда, а нулевой срез не имеет адреса
```go
var data []string # nil
data = []string(nil) # nil
data = []string{} # empty
data = make([]string, 0) # empty
```

#### Можно ли сравнивать срезы?
- Нет
- Можно использовать reflect.DeepEqual (Долго робит)
- slices.equal есть

#### Как скопировать данные слайса?
+ Функция `copy` копирует число элементов равное минимум из правого и левого слайса
```go
src := []int{1, 2, 3}
var dst []int
copy(dst, src) # Тут ничего не скопируется

dst := make([]int, 3)
copy(dst, src) # Тут нормально все
```
+ slices.Clone - делает глубокую копию

Супер прикол, ну ваще ожидаемо
![[Pasted image 20250629122519.png]]
#### Память у слайсов течет
+ Если ты выделяешь большую область памяти и потом какой нибудь указатель или части этой памяти ты фиксируешь, то пока что то есть указывающее на эту область, сборщик не удалит ее. Как в примере с капой
![[Pasted image 20250629123719.png]]
