Микросервисы отвечают за 1 бизнес задачу.
Могут быть запущены независимо от других приложений. Можно запустить сколько угодно реплик.
### Что такое CQRS (Command and Query Responsibility Segregation)?

Это паттерн, который говорит о разделении запросов на чтение и на изменения объекта (Разделение на команды и запросы).

У каждого микросервиса своя БД. Как нам свести все эти данные в одну точку, где мы хотим их использовать? В этом и поможет SQRS паттерн.

Создаются две модели: Write Model и Read Model.

- Клиент → отправляет **Command** в сервис записи (Write Model).
- Write Model → обрабатывает, валидирует, изменяет данные.
- Write Model → генерирует **Event** (например, "OrderCreated"). И отправляет его в kafka
- Read Model → получает это событие и обновляет **свою базу**, чтобы быть в актуальном состоянии.
- Клиент → отправляет **Query** в сервис чтения (Read Model) → получает быстрый результат.

##### База одна или две?
- Чаще всего — **две разные базы**:
    - **Write DB** — транзакционная, нормализованная (PostgreSQL, MySQL).
    - **Read DB** — быстрая, денормализованная, заточена под запросы (MongoDB, ElasticSearch, Redis).
- Но бывает и **одна база**, где:
    - разные схемы / таблицы используются для записи и чтения,
    - либо используются **реплики БД** (master → write, replicas → read).


### Что такое Event sourcing?

**Event Sourcing** — это паттерн хранения данных, при котором состояние системы **не хранится напрямую** (как обычная запись в таблице), а вместо этого сохраняется **последовательность событий**, которые к этому состоянию привели.

- В традиционной системе:
    - У тебя в базе есть таблица `orders` и там строка: `id=123, status=PAID`.
- В Event Sourcing:
    - В базе нет "строки заказа", а есть события:
        - `OrderCreated (id=123, user=45)`
        - `ItemAdded (order_id=123, product=67, qty=2)`
        - `OrderPaid (id=123, amount=1000)`
    - Текущее состояние (`status=PAID`) вычисляется **как результат применения всех событий**.

В Event Sourcing база хранит **историю всех событий для всех заказов**. То есть вместо строки _"Заказ №123, статус = PAID"_ у тебя лежит последовательность событий

#### Как получить итоговое состояние заказа?
###### **Проигрывание событий (replay)**
Ты берёшь все события для заказа №123, сортируешь по времени и "применяешь" их к пустой модели

###### **Read model**
Чтобы каждый раз не гонять 1000+ событий, делают **Read Model** (как в CQRS):
- Есть сервис, который слушает события (например, Kafka).
- Приходит событие `OrderPaid` → в Read DB обновляется запись

###### **Практический приём: снапшоты**
Если заказ живёт очень долго и событий у него тысячи:
- Можно хранить "снимок" (snapshot) состояния раз в N событий.
- При восстановлении состояния нужно проиграть только последние события после снапшота.

## Stability patterns

Это паттерны, которые отвечают за стабилизацию нашей системы и направлены на то, что система не вышла из строя.

### Retry pattern
Если соединение с сервисом оборвалось, этот паттерн попытается его восстановить. Он имеет параметры количество раз попробовать восстановить соединение и значение интервала.

### Timeout pattern 
Установка ограничения времени ожидания восстановления соединения и максимальное время ожидание при обмене данными.
